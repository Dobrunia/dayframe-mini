<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Daytime Mini</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: { extend: { fontFamily: { sans: ['Inter', 'system-ui', 'sans-serif'] } } },
      };
    </script>
    <style>
      /* Кастомные чекбоксы */
      input[type='checkbox'] {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background: rgb(38 38 38);
        border: 2px solid rgb(82 82 82);
        border-radius: 0.5rem;
        transition: 0.2s;
        cursor: pointer;
      }
      input[type='checkbox']:hover {
        border-color: rgb(52 211 153);
      }
      input[type='checkbox']:checked {
        background: rgb(16 185 129);
        border-color: rgb(16 185 129);
        background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='m13.854 3.646-7.5 7.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6 10.293l7.146-7.147a.5.5 0 0 1 .708.708z'/%3e%3c/svg%3e");
        background-size: 12px 12px;
        background-position: center;
        background-repeat: no-repeat;
      }
      input[type='checkbox']:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgb(16 185 129 / 0.5);
      }
      /* Канвас фона на весь экран */
      #graphBackground canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body
    class="bg-neutral-950 text-neutral-100 min-h-screen font-sans text-base relative overflow-hidden"
  >
    <!-- Animated Background -->
    <div id="graphBackground" class="fixed inset-0 pointer-events-none"></div>

    <header class="max-w-4xl mx-auto px-4 py-6 flex items-center justify-between relative z-20">
      <div id="today" class="text-2xl font-semibold"></div>
      <div class="flex items-center gap-4">
        <select
          id="backgroundSelect"
          class="px-3 py-2 rounded-lg bg-neutral-800 text-neutral-100 border border-neutral-700 focus:outline-none focus:border-emerald-500"
        >
          <option value="anime-water">Аниме вода</option>
          <option value="dvd-bounce">DVD заставка</option>
        </select>
        <button
          id="btnNew"
          class="px-6 py-3 rounded-lg bg-emerald-500 hover:bg-emerald-600 text-white font-medium text-lg"
        >
          + Создать задачу
        </button>
      </div>
    </header>

    <main class="max-w-4xl mx-auto px-4 pb-24 relative z-20">
      <div id="list" class="space-y-4"></div>
    </main>

    <!-- Модал создания задачи -->
    <div id="modal" class="fixed inset-0 hidden items-center justify-center bg-black/60">
      <div class="bg-neutral-900 w-full max-w-lg rounded-xl p-6">
        <div class="text-xl font-semibold mb-4">Новая задача</div>
        <label class="block mb-4 text-base">
          Заголовок
          <input
            id="mTitle"
            class="mt-2 w-full px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
            placeholder="Например: Презентация"
          />
        </label>
        <label class="block mb-4 text-base">
          Длительность (мин)
          <input
            id="mMinutes"
            type="number"
            min="1"
            value="25"
            class="mt-2 w-32 px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
          />
        </label>
        <label class="block mb-4 text-base">
          Время начала
          <input
            id="mPlannedTime"
            type="time"
            class="mt-2 w-32 px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
          />
        </label>
        <label class="block mb-4 text-base">
          Подзадачи (по одной в строке)
          <textarea
            id="mSubs"
            rows="4"
            class="mt-2 w-full px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
            placeholder="Слайды&#10;Сценарий&#10;Репетиция"
          ></textarea>
        </label>
        <div class="flex gap-3 justify-end mt-6">
          <button
            id="mCancel"
            class="px-6 py-3 rounded-lg bg-neutral-700 hover:bg-neutral-600 text-base font-medium"
          >
            Отмена
          </button>
          <button
            id="mSave"
            class="px-6 py-3 rounded-lg bg-emerald-500 hover:bg-emerald-600 text-white text-base font-medium"
          >
            Сохранить
          </button>
        </div>
      </div>
    </div>

    <!-- Модал редактирования задачи -->
    <div id="editModal" class="fixed inset-0 hidden items-center justify-center bg-black/60">
      <div class="bg-neutral-900 w-full max-w-lg rounded-xl p-6">
        <div class="text-xl font-semibold mb-4">Редактировать задачу</div>
        <label class="block mb-4 text-base">
          Заголовок
          <input
            id="eTitle"
            class="mt-2 w-full px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
            placeholder="Например: Презентация"
          />
        </label>
        <label class="block mb-4 text-base">
          Длительность (мин)
          <input
            id="eMinutes"
            type="number"
            min="1"
            value="25"
            class="mt-2 w-32 px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
          />
        </label>
        <label class="block mb-4 text-base">
          Время начала
          <input
            id="ePlannedTime"
            type="time"
            class="mt-2 w-32 px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
          />
        </label>
        <label class="block mb-4 text-base">
          Подзадачи (по одной в строке)
          <textarea
            id="eSubs"
            rows="4"
            class="mt-2 w-full px-4 py-3 rounded-lg bg-neutral-800 outline-none text-base"
            placeholder="Слайды&#10;Сценарий&#10;Репетиция"
          ></textarea>
        </label>
        <div class="flex gap-3 justify-between mt-6">
          <button
            id="eDelete"
            class="px-6 py-3 rounded-lg bg-red-500 hover:bg-red-600 text-white text-base font-medium"
          >
            Удалить
          </button>
          <div class="flex gap-3">
            <button
              id="eCancel"
              class="px-6 py-3 rounded-lg bg-neutral-700 hover:bg-neutral-600 text-base font-medium"
            >
              Отмена
            </button>
            <button
              id="eSave"
              class="px-6 py-3 rounded-lg bg-emerald-500 hover:bg-emerald-600 text-white text-base font-medium"
            >
              Сохранить
            </button>
          </div>
        </div>
      </div>
    </div>

    <audio id="beep" src="./time-over.mp3" preload="auto"></audio>

    <script>
      // ===== Web Worker для фонового таймера =====
      let timerWorker = null;

      function createTimerWorker() {
        if (timerWorker) return timerWorker;

        const workerCode = `
          let timers = new Map();
          
          self.onmessage = function(e) {
            const { action, taskId, minutes } = e.data;
            
            switch(action) {
              case 'start':
                if (timers.has(taskId)) {
                  clearInterval(timers.get(taskId));
                }
                const intervalId = setInterval(() => {
                  self.postMessage({ action: 'tick', taskId });
                }, 1000);
                timers.set(taskId, intervalId);
                break;
                
              case 'stop':
                if (timers.has(taskId)) {
                  clearInterval(timers.get(taskId));
                  timers.delete(taskId);
                }
                break;
                
              case 'stopAll':
                timers.forEach(id => clearInterval(id));
                timers.clear();
                break;
            }
          };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        timerWorker = new Worker(URL.createObjectURL(blob));

        timerWorker.onmessage = function (e) {
          const { action, taskId } = e.data;
          if (action === 'tick') {
            handleTimerTick(taskId);
          }
        };

        return timerWorker;
      }

      function handleTimerTick(taskId) {
        if (!timers.has(taskId)) return;

        const st = timers.get(taskId);
        st.remainMs -= 1000;

        // Обновляем UI
        const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
        if (taskElement) {
          const timerEl = taskElement.querySelector('.timer-display');
          if (timerEl) {
            timerEl.textContent = formatMMSS(st.remainMs);
          }
        }

        if (st.remainMs <= 0) {
          // Таймер завершен
          timerWorker.postMessage({ action: 'stop', taskId });
          st.remainMs = 0;
          st.running = false;

          // Обновляем кнопку
          const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
          if (taskElement) {
            const btnEl = taskElement.querySelector('.timer-btn');
            if (btnEl) {
              btnEl.textContent = 'Старт';
              btnEl.className =
                'px-4 py-2 rounded-lg bg-indigo-500 hover:bg-indigo-600 text-white text-base font-medium border-2 border-transparent';
            }
          }

          // Звук и уведомление
          const beep = document.getElementById('beep');
          const task = DATA.find((x) => x.id === taskId);
          const title = task ? task.title : '';

          try {
            beep.currentTime = 0;
            beep.play();
            setTimeout(() => {
              beep.pause();
              beep.currentTime = 0;
            }, 3000);
          } catch {}

          notify('Таймер завершён', `Задача: ${title}`);
        }
      }
      // ===== Время (Москва) =====
      const MSK = 'Europe/Moscow';
      const fmtDate = (d) =>
        new Intl.DateTimeFormat('ru-RU', { dateStyle: 'full', timeZone: MSK }).format(d);
      const todayKey = () => new Intl.DateTimeFormat('sv-SE', { timeZone: MSK }).format(new Date());

      // ===== API helpers =====
      async function apiGet(url, fallback) {
        try {
          const r = await fetch(url, { cache: 'no-store' });
          if (r.ok) return await r.json();
        } catch (e) {
          console.warn('GET fail', url, e);
        }
        return fallback;
      }
      async function apiPut(url, data) {
        try {
          await fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
          });
        } catch (e) {
          console.warn('PUT fail', url, e);
        }
      }

      // ===== Состояние =====
      let DATA = [],
        DONE = {};
      async function loadStateFromServer() {
        DATA = await apiGet('/api/data', []);
        DONE = await apiGet('/api/done', {});
        if (!Array.isArray(DATA)) {
          DATA = [];
          await apiPut('/api/data', DATA);
        }
        if (!DONE || typeof DONE !== 'object') {
          DONE = {};
          await apiPut('/api/done', DONE);
        }
      }
      async function saveData() {
        await apiPut('/api/data', DATA);
      }
      async function saveDone() {
        await apiPut('/api/done', DONE);
      }

      // ===== Уведомления =====
      async function ensureNotifyPermission() {
        if (!('Notification' in window)) return false;
        if (Notification.permission === 'granted') return true;
        if (Notification.permission !== 'denied') {
          try {
            return (await Notification.requestPermission()) === 'granted';
          } catch {
            return false;
          }
        }
        return false;
      }
      function notify(title, body) {
        try {
          new Notification(title, { body });
        } catch {}
      }

      // ===== Рендер задач =====
      const elList = document.getElementById('list');
      const elToday = document.getElementById('today');
      elToday.textContent = fmtDate(new Date());
      const timers = new Map(); // taskId -> { remainMs, id, running }

      function render() {
        const day = todayKey();
        const doneSet = new Set(DONE[day] || []);
        elList.innerHTML = '';
        const sorted = [...DATA].sort((a, b) => {
          // Сначала задачи с plannedTime (по времени начала)
          const aHasTime = !!a.plannedTime;
          const bHasTime = !!b.plannedTime;

          if (aHasTime && !bHasTime) return -1;
          if (!aHasTime && bHasTime) return 1;

          if (aHasTime && bHasTime) {
            // Обе имеют время - сортируем по времени
            return a.plannedTime.localeCompare(b.plannedTime);
          } else {
            // Обе без времени - сортируем по алфавиту
            return a.title.localeCompare(b.title);
          }
        });
        sorted.forEach((task) => elList.appendChild(renderTask(task, doneSet.has(task.id))));
      }
      function renderTask(task, isDone) {
        const card = document.createElement('div');
        card.className = 'rounded-xl bg-neutral-900 p-6 border border-neutral-800';
        card.setAttribute('data-task-id', task.id);
        const header = document.createElement('div');
        header.className = 'flex items-center gap-4';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = isDone;
        cb.className = 'size-6';
        cb.id = `task-${task.id}`;
        cb.addEventListener('change', async () => {
          await toggleDone(task.id, cb.checked);
        });
        const title = document.createElement('label');
        title.className = 'flex-1 font-semibold text-lg cursor-pointer';
        title.textContent = task.title;
        title.setAttribute('for', `task-${task.id}`);
        const timer = document.createElement('div');
        timer.className = 'text-base text-neutral-400 font-mono timer-display';
        timer.dataset.minutes = task.minutes ?? 25;
        timer.textContent = formatMMSS((task.minutes ?? 25) * 60 * 1000);
        const planned = document.createElement('div');
        planned.className = 'text-sm text-neutral-400';
        planned.textContent = task.plannedTime ? `Начало в ${task.plannedTime}` : '';
        const btnEdit = document.createElement('button');
        btnEdit.className =
          'p-2 rounded-lg bg-neutral-700 hover:bg-neutral-600 text-neutral-300 hover:text-white';
        btnEdit.innerHTML = '✏️';
        btnEdit.title = 'Редактировать задачу';
        btnEdit.addEventListener('click', () => openEditModal(task));
        const btnStart = document.createElement('button');
        btnStart.className =
          'px-4 py-2 rounded-lg bg-indigo-500 hover:bg-indigo-600 text-white text-base font-medium border-2 border-transparent timer-btn';
        btnStart.textContent = 'Старт';
        btnStart.addEventListener('click', () => toggleTimer(task.id, timer, btnStart));
        if (timers.has(task.id)) {
          const st = timers.get(task.id);
          timer.textContent = formatMMSS(st.remainMs);
          btnStart.textContent = st.running ? 'Стоп' : 'Старт';
          if (st.running) {
            btnStart.className =
              'px-4 py-2 rounded-lg bg-transparent border-2 border-red-500 text-red-500 hover:bg-red-500/10 text-base font-medium';
          }
        }
        header.append(cb, title, timer, btnEdit, btnStart);
        card.appendChild(header);
        if (task.plannedTime) card.appendChild(planned);
        if (Array.isArray(task.subtasks) && task.subtasks.length) {
          const ul = document.createElement('ul');
          ul.className = 'mt-4 grid gap-3';
          task.subtasks.forEach((s) => {
            const li = document.createElement('li');
            li.className = 'flex items-center gap-3';
            const c = document.createElement('input');
            c.type = 'checkbox';
            c.className = 'size-5';
            c.id = `subtask-${task.id}-${s.replace(/\s+/g, '-')}`;
            c.addEventListener('change', () => {
              li.classList.toggle('opacity-50', c.checked);
              t.classList.toggle('line-through', c.checked);
            });
            const t = document.createElement('label');
            t.className = 'text-base text-neutral-300 cursor-pointer flex-1';
            t.textContent = s;
            t.setAttribute('for', `subtask-${task.id}-${s.replace(/\s+/g, '-')}`);
            li.append(c, t);
            ul.appendChild(li);
          });
          card.appendChild(ul);
        }
        if (isDone) {
          card.classList.add('opacity-60');
          title.classList.add('line-through');
        }
        return card;
      }
      function formatMMSS(ms) {
        const sec = Math.max(0, Math.round(ms / 1000));
        const m = String(Math.floor(sec / 60)).padStart(2, '0');
        const s = String(sec % 60).padStart(2, '0');
        return `${m}:${s}`;
      }
      function startInterval(taskId, labelEl, btn) {
        const st = timers.get(taskId);
        if (!st) return;
        st.running = true;
        btn.textContent = 'Стоп';
        btn.disabled = false;
        btn.className =
          'px-4 py-2 rounded-lg bg-transparent border-2 border-red-500 text-red-500 hover:bg-red-500/10 text-base font-medium';
        const task = DATA.find((x) => x.id === taskId);
        if (task && !task.startTime) {
          task.startTime = Date.now();
          saveData();
        }

        // Запускаем таймер через Web Worker
        createTimerWorker();
        timerWorker.postMessage({ action: 'start', taskId });
      }
      async function toggleTimer(taskId, labelEl, btn) {
        await ensureNotifyPermission();
        if (!timers.has(taskId)) {
          const minutes = parseInt(labelEl.dataset.minutes || '25', 10);
          timers.set(taskId, { remainMs: minutes * 60 * 1000, id: null, running: false });
        }
        const st = timers.get(taskId);
        if (st.running) {
          // Останавливаем таймер через Web Worker
          if (timerWorker) {
            timerWorker.postMessage({ action: 'stop', taskId });
          }
          st.running = false;
          btn.textContent = 'Старт';
          btn.className =
            'px-4 py-2 rounded-lg bg-indigo-500 hover:bg-indigo-600 text-white text-base font-medium border-2 border-transparent';
          return;
        }
        startInterval(taskId, labelEl, btn);
      }
      async function toggleDone(taskId, checked) {
        if (timers.has(taskId)) {
          const st = timers.get(taskId);
          if (st.running && timerWorker) {
            timerWorker.postMessage({ action: 'stop', taskId });
          }
          timers.delete(taskId);
        }
        const day = todayKey();
        const arr = Array.from(new Set([...(DONE[day] || [])]));
        if (checked) {
          if (!arr.includes(taskId)) arr.push(taskId);
        } else {
          const i = arr.indexOf(taskId);
          if (i >= 0) arr.splice(i, 1);
        }
        DONE[day] = arr;
        await saveDone();
        render();
      }

      // ===== Модалки (создание/редактирование) =====
      const modal = document.getElementById('modal');
      document.getElementById('btnNew').onclick = () => {
        modal.classList.remove('hidden');
        modal.classList.add('flex');
      };
      document.getElementById('mCancel').onclick = () => {
        modal.classList.add('hidden');
      };
      document.getElementById('mSave').onclick = async () => {
        const title = document.getElementById('mTitle').value.trim();
        const minutes = parseInt(document.getElementById('mMinutes').value || '25', 10);
        const plannedTime = document.getElementById('mPlannedTime').value;
        const subs = document
          .getElementById('mSubs')
          .value.split('\n')
          .map((s) => s.trim())
          .filter(Boolean);
        if (!title) return;
        DATA.push({
          id: crypto.randomUUID(),
          title,
          minutes,
          plannedTime: plannedTime || null,
          subtasks: subs,
          createdAt: Date.now(),
        });
        await saveData();
        modal.classList.add('hidden');
        document.getElementById('mTitle').value = '';
        document.getElementById('mPlannedTime').value = '';
        document.getElementById('mSubs').value = '';
        render();
      };
      let currentEditTask = null;
      const editModal = document.getElementById('editModal');
      function openEditModal(task) {
        currentEditTask = task;
        document.getElementById('eTitle').value = task.title;
        document.getElementById('eMinutes').value = task.minutes || 25;
        document.getElementById('ePlannedTime').value = task.plannedTime || '';
        document.getElementById('eSubs').value = (task.subtasks || []).join('\n');
        editModal.classList.remove('hidden');
        editModal.classList.add('flex');
      }
      document.getElementById('eCancel').onclick = () => {
        editModal.classList.add('hidden');
        currentEditTask = null;
      };
      document.getElementById('eSave').onclick = async () => {
        if (!currentEditTask) return;
        const title = document.getElementById('eTitle').value.trim();
        const minutes = parseInt(document.getElementById('eMinutes').value || '25', 10);
        const plannedTime = document.getElementById('ePlannedTime').value;
        const subs = document
          .getElementById('eSubs')
          .value.split('\n')
          .map((s) => s.trim())
          .filter(Boolean);
        if (!title) return;
        const i = DATA.findIndex((t) => t.id === currentEditTask.id);
        if (i !== -1) {
          DATA[i] = {
            ...DATA[i],
            title,
            minutes,
            plannedTime: plannedTime || null,
            subtasks: subs,
          };
          await saveData();
        }
        editModal.classList.add('hidden');
        currentEditTask = null;
        render();
      };
      document.getElementById('eDelete').onclick = async () => {
        if (!currentEditTask) return;
        if (!confirm(`Вы уверены, что хотите удалить задачу "${currentEditTask.title}"?`)) return;
        const i = DATA.findIndex((t) => t.id === currentEditTask.id);
        if (i !== -1) {
          DATA.splice(i, 1);
          await saveData();
        }
        if (timers.has(currentEditTask.id)) {
          const st = timers.get(currentEditTask.id);
          if (st.running && timerWorker) {
            timerWorker.postMessage({ action: 'stop', taskId: currentEditTask.id });
          }
          timers.delete(currentEditTask.id);
        }
        editModal.classList.add('hidden');
        currentEditTask = null;
        render();
      };

      // ===== DVD заставка =====
      function createDVDBackground() {
        const container = document.getElementById('graphBackground');
        container.innerHTML = '';
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        container.appendChild(canvas);

        let x = 100,
          y = 100;
        let dx = 2,
          dy = 1.5;
        const logo = 'DVD';
        const logoSize = 48;
        let logoColor = '#ff6b6b';

        function resize() {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = Math.floor(window.innerWidth * dpr);
          canvas.height = Math.floor(window.innerHeight * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function animate() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Обновляем позицию
          x += dx;
          y += dy;

          // Отскок от стен
          if (x <= 0 || x >= canvas.width - logoSize * 3) {
            dx = -dx;
            logoColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
          }
          if (y <= 0 || y >= canvas.height - logoSize) {
            dy = -dy;
            logoColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
          }

          // Рисуем логотип
          ctx.fillStyle = logoColor;
          ctx.font = `bold ${logoSize}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(logo, x, y);

          requestAnimationFrame(animate);
        }

        resize();
        window.addEventListener('resize', resize);
        animate();
      }

      // ===== Фон: «растущая» Voronoi-заливка без общего таймера =====
      // перезапуск только когда все области уже доросли до краёв
      function createVoronoiWaveBackground() {
        const container = document.getElementById('graphBackground');
        container.innerHTML = '';
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        container.appendChild(canvas);

        // --- параметры яркости/скорости ---
        const SCALE = 0.25; // внутренний буфер (производительность)
        const GROW_SPEED = 1; // пикселей в секунду (медленно). Уменьши — будет ещё медленнее
        const GRID_ALPHA = 0.0; // заметность сетки
        const VEIL_ALPHA = 0.015; // тёмная «вуаль» поверх — меньше => ярче

        // состояние
        let buf, bctx, W, H; // размеры «низкого» буфера
        let seeds, owner, dist2; // точки, для каждого пикселя: чей «владелец» и расстояние^2
        let colors; // h,s,l,a для каждой ячейки
        let last = undefined; // время прошлого кадра
        let r = 0,
          r2 = 0,
          maxR = 1; // текущий радиус заливки (в пикселях буфера)
        let maxD2 = 1; // максимум из dist2 по всему буферу
        let restarting = false; // флаг перезапуска

        function resize() {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = Math.floor(window.innerWidth * dpr);
          canvas.height = Math.floor(window.innerHeight * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          W = Math.max(200, Math.floor(window.innerWidth * SCALE));
          H = Math.max(140, Math.floor(window.innerHeight * SCALE));
          buf = document.createElement('canvas');
          buf.width = W;
          buf.height = H;
          bctx = buf.getContext('2d');
          bctx.imageSmoothingEnabled = false;

          buildField(); // новые точки и заполнение dist2/maxD2
          r = 0;
          r2 = 0;
          maxR = Math.sqrt(maxD2); // вместо hypot(W, H)
          last = undefined;
        }

        function buildField() {
          const N = 48; // сколько «шаров»
          seeds = new Array(N);
          colors = new Array(N);
          for (let i = 0; i < N; i++) {
            seeds[i] = [Math.random() * W, Math.random() * H];
            // Аниме вода: синие оттенки (180-220 градусов)
            const h = 180 + Math.random() * 40; // от голубого до синего
            const s = 60 + Math.random() * 30; // насыщенность 60-90%
            const l = 45 + Math.random() * 20; // светлота 45-65%
            colors[i] = [h, s, l, 0.85];
          }

          owner = new Uint16Array(W * H);
          dist2 = new Float32Array(W * H);
          maxD2 = 0;

          // предрассчёт «кто ближе» и расстояний
          for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
              let best = 0,
                bestD2 = Infinity;
              for (let s = 0; s < N; s++) {
                const dx = x - seeds[s][0],
                  dy = y - seeds[s][1];
                const d2 = dx * dx + dy * dy;
                if (d2 < bestD2) {
                  bestD2 = d2;
                  best = s;
                }
              }
              const idx = y * W + x;
              owner[idx] = best;
              dist2[idx] = bestD2;
              if (bestD2 > maxD2) maxD2 = bestD2; // накопление maxD2
            }
          }
        }

        // быстрый HSL -> RGB
        function hslToRgb(h, s, l) {
          if (s === 0) {
            const v = l * 255;
            return [v, v, v];
          }
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          const to = (t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };
          return [
            Math.round(to(h + 1 / 3) * 255),
            Math.round(to(h) * 255),
            Math.round(to(h - 1 / 3) * 255),
          ];
        }

        function drawFrame(now) {
          // dt в секундах
          const dt = (now - (last ?? now)) / 1000;
          last = now;

          // рост радиуса (очень медленно). Уменьшай GROW_SPEED — будет ещё медленнее.
          if (r < maxR && !restarting) {
            r += GROW_SPEED * dt;
            r2 = r * r;
          }

          // буфер пикселей
          const id = bctx.createImageData(W, H);
          const data = id.data;

          // Создаем карту пересечений для белых линий
          const intersectionMap = new Uint8Array(W * H);

          for (let i = 0, p = 0; i < owner.length; i++, p += 4) {
            if (dist2[i] <= r2) {
              // Проверяем пересечения с соседними областями
              const x = i % W;
              const y = Math.floor(i / W);
              let isIntersection = false;

              // Проверяем соседние пиксели на границах областей
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  if (dx === 0 && dy === 0) continue;
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                    const nIdx = ny * W + nx;
                    if (dist2[nIdx] <= r2 && owner[nIdx] !== owner[i]) {
                      isIntersection = true;
                      break;
                    }
                  }
                }
                if (isIntersection) break;
              }

              if (isIntersection) {
                // Белые пересечения
                data[p] = 255;
                data[p + 1] = 255;
                data[p + 2] = 255;
                data[p + 3] = 255;
              } else {
                // Обычные синие области
                const [h, s, l, a] = colors[owner[i]];
                const [R, G, B] = hslToRgb(h / 360, s / 100, l / 100);
                data[p] = R;
                data[p + 1] = G;
                data[p + 2] = B;
                data[p + 3] = Math.round(a * 255);
              }
            } else {
              // прозрачный фон
              data[p] = data[p + 1] = data[p + 2] = 0;
              data[p + 3] = 0;
            }
          }
          bctx.putImageData(id, 0, 0);

          // тонкая сетка (в буфере)
          bctx.strokeStyle = `rgba(55,65,81,${GRID_ALPHA})`;
          bctx.lineWidth = 1;
          const step = Math.max(40, Math.floor(140 * SCALE));
          for (let x = 0; x < W; x += step) {
            bctx.beginPath();
            bctx.moveTo(x, 0);
            bctx.lineTo(x, H);
            bctx.stroke();
          }
          for (let y = 0; y < H; y += step) {
            bctx.beginPath();
            bctx.moveTo(0, y);
            bctx.lineTo(W, y);
            bctx.stroke();
          }

          // вывод на основной канвас
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(buf, 0, 0, canvas.width, canvas.height);

          // лёгкая тёмная вуаль (меньше альфа → фон ярче)
          ctx.fillStyle = `rgba(0,0,0,${VEIL_ALPHA})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // === Перезапуск только когда залилось всё ===
          if (!restarting && r2 >= maxD2 - 1e-3) {
            // -epsilon на всякий случай
            restarting = true; // ставим флаг один раз
            setTimeout(() => {
              buildField(); // новые точки
              r = 0;
              r2 = 0; // радиус с нуля
              maxR = Math.sqrt(maxD2);
              last = undefined; // важный сброс для корректного dt
              restarting = false; // снимаем флаг
            }, 300);
          }

          requestAnimationFrame(drawFrame);
        }

        resize();
        window.addEventListener('resize', resize);
        requestAnimationFrame(drawFrame);
      }

      // ===== Переключение фонов =====
      let currentBackground = 'anime-water';

      function switchBackground(type) {
        if (type === currentBackground) return;
        currentBackground = type;

        if (type === 'anime-water') {
          createVoronoiWaveBackground();
        } else if (type === 'dvd-bounce') {
          createDVDBackground();
        }
      }

      document.getElementById('backgroundSelect').addEventListener('change', (e) => {
        switchBackground(e.target.value);
      });

      // Инициализация
      loadStateFromServer().then(() => {
        render();
      });

      // Инициализируем Web Worker для таймеров
      createTimerWorker();

      // Запускаем аниме воду по умолчанию
      createVoronoiWaveBackground();
    </script>
  </body>
</html>
